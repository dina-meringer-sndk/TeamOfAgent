# Project Knowledge Base Template
# Generated by Test Code Generator Agent - Learn Project Context Task
# This template provides a standardized structure for capturing project analysis

project_metadata:
  name: "[PROJECT_NAME]"
  repository_url: "[REPO_URL]"
  primary_language: "[LANGUAGE]"
  project_type: "[TYPE]" # e.g., validation, web-app, microservice, etc.
  analysis_date: "[DATE]"
  agent_version: "[AGENT_VERSION]"

project_structure:
  root_directories:
    - "[DIR1]"
    - "[DIR2]"
  test_directories:
    - "[TEST_DIR1]"
    - "[TEST_DIR2]"
  source_to_test_mapping:
    "[SOURCE_DIR]": "[TEST_DIR]"
  build_system: "[BUILD_SYSTEM]" # e.g., setuptools, poetry, maven, gradle
  dependency_management: "[DEP_MANAGER]" # e.g., requirements.txt, pyproject.toml

testing_framework:
  primary_framework: "[FRAMEWORK]" # e.g., pytest, unittest, junit
  secondary_frameworks: 
    - "[FRAMEWORK2]"
  assertion_style: "[STYLE]" # e.g., assert statements, hamcrest, fluent
  test_organization:
    unit_tests: "[LOCATION/PATTERN]"
    integration_tests: "[LOCATION/PATTERN]"
    validation_tests: "[LOCATION/PATTERN]"
  test_execution:
    command: "[COMMAND]" # e.g., pytest, python -m unittest
    config_files:
      - "[CONFIG_FILE1]"
  mocking_strategy: "[STRATEGY]" # e.g., unittest.mock, pytest-mock, mockito

code_conventions:
  naming_conventions:
    classes: "[PATTERN]" # e.g., PascalCase, snake_case
    methods: "[PATTERN]"
    variables: "[PATTERN]"
    test_files: "[PATTERN]"
    test_classes: "[PATTERN]"
    test_methods: "[PATTERN]"
  style_guide: "[GUIDE]" # e.g., PEP 8, Google Style, Black formatted
  documentation_style: "[STYLE]" # e.g., docstrings, sphinx, javadoc
  error_handling:
    exception_patterns:
      - "[PATTERN1]"
    validation_approach: "[APPROACH]"
  architectural_patterns:
    - "[PATTERN1]" # e.g., MVC, Repository, Factory
  package_organization: "[STRUCTURE]"

python_specific:
  version: "[VERSION]"
  virtual_environment: "[VENV_TYPE]" # e.g., venv, conda, pipenv
  dependencies:
    testing:
      - "[PACKAGE]: [VERSION]"
    validation:
      - "[PACKAGE]: [VERSION]"
    xml_json_handling:
      - "[PACKAGE]: [VERSION]"
  import_patterns:
    - "[PATTERN1]"
  code_quality_tools:
    linter: "[TOOL]" # e.g., pylint, flake8
    formatter: "[TOOL]" # e.g., black, autopep8
    type_checker: "[TOOL]" # e.g., mypy, pyright

validation_patterns:
  validation_frameworks:
    - name: "[FRAMEWORK]"
      usage: "[USAGE_PATTERN]"
  xml_usage:
    file_locations:
      - "[LOCATION1]"
    purposes:
      - "[PURPOSE1]" # e.g., test data, schemas, API payloads
    parsing_libraries:
      - "[LIBRARY1]"
    validation_approach: "[APPROACH]"
  json_usage:
    file_locations:
      - "[LOCATION1]"
    purposes:
      - "[PURPOSE1]"
    schema_validation: "[APPROACH]"
    parsing_libraries:
      - "[LIBRARY1]"
  test_data_management:
    organization: "[STRUCTURE]"
    generation_patterns:
      - "[PATTERN1]"
    fixture_strategy: "[STRATEGY]"

business_domain:
  domain_concepts:
    - name: "[CONCEPT1]"
      description: "[DESCRIPTION]"
  business_rules:
    - rule: "[RULE1]"
      implementation: "[LOCATION]"
  validation_rules:
    - type: "[TYPE]" # e.g., data validation, business logic
      description: "[DESCRIPTION]"
      enforcement: "[METHOD]"
  workflows:
    - name: "[WORKFLOW1]"
      steps:
        - "[STEP1]"
  terminology:
    "[TERM1]": "[DEFINITION1]"

existing_code_inventory:
  utility_locations:
    - directory: "[DIR_PATH]"
      purpose: "[PURPOSE]" # e.g., validation, parsing, testing
  utilities_by_category:
    validation:
      - name: "[CLASS_NAME]"
        file_path: "[PATH]"
        functionality: "[DESCRIPTION]"
        public_methods:
          - "[METHOD1]"
        reusability_score: "[SCORE]" # high, medium, low
    xml_json:
      - name: "[CLASS_NAME]"
        file_path: "[PATH]"
        functionality: "[DESCRIPTION]"
        public_methods:
          - "[METHOD1]"
        reusability_score: "[SCORE]"
    testing:
      - name: "[CLASS_NAME]"
        file_path: "[PATH]"
        functionality: "[DESCRIPTION]"
        public_methods:
          - "[METHOD1]"
        reusability_score: "[SCORE]"
    data_manipulation:
      - name: "[CLASS_NAME]"
        file_path: "[PATH]"
        functionality: "[DESCRIPTION]"
        public_methods:
          - "[METHOD1]"
        reusability_score: "[SCORE]"
  search_patterns:
    naming_conventions:
      - "[PATTERN1]" # e.g., *Helper, *Util, *Manager
    common_imports:
      - "[IMPORT1]" # frequently imported utilities
  reusability_guidelines:
    extend_existing_criteria:
      - "[CRITERIA1]" # e.g., compatible interface, good code quality
    create_new_criteria:
      - "[CRITERIA1]" # e.g., poor design, incompatible interface
    decision_framework:
      high_reusability: "[ACTION]" # extend existing
      medium_reusability: "[ACTION]" # evaluate case-by-case
      low_reusability: "[ACTION]" # create new

integration_guidelines:
  test_generation_strategy:
    preferred_patterns:
      - "[PATTERN1]"
    naming_conventions:
      test_files: "[PATTERN]"
      test_classes: "[PATTERN]"
      test_methods: "[PATTERN]"
  compatibility_requirements:
    - "[REQUIREMENT1]"
  quality_standards:
    code_coverage: "[TARGET]"
    test_independence: "[REQUIREMENT]"
    performance_considerations:
      - "[CONSIDERATION1]"

file_analysis_summary:
  total_files_analyzed: "[COUNT]"
  test_files_found: "[COUNT]"
  xml_files_analyzed: "[COUNT]"
  json_files_analyzed: "[COUNT]"
  validation_rules_extracted: "[COUNT]"
  patterns_identified: "[COUNT]"

recommendations:
  test_generation:
    - "[RECOMMENDATION1]"
  integration_approach:
    - "[RECOMMENDATION1]"
  potential_issues:
    - issue: "[ISSUE1]"
      mitigation: "[MITIGATION]"

notes:
  special_considerations:
    - "[CONSIDERATION1]"
  manual_review_needed:
    - "[ITEM1]"
  confidence_level: "[LEVEL]" # e.g., high, medium, low